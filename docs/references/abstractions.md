[src-disc]: https://github.com/feature-sliced/wiki/discussions/31
[disc-poll]: https://github.com/feature-sliced/wiki/discussions/31#discussioncomment-464894
[disc-list]: https://github.com/feature-sliced/wiki/discussions/
[disc-processes]: https://github.com/feature-sliced/wiki/discussions/20
[disc-model]: https://github.com/feature-sliced/wiki/discussions/68
[disc-usability]: https://github.com/feature-sliced/wiki/discussions/65
[tg-description]: https://t.me/atomicdesign/18951
[ref-app-splitting]: ../concepts/app-splitting.md
[ref-naming-adaptability]: ../concepts/naming-adaptability.md

# Абстракции
> Про абстракции в методологии и их назначение в проекте

---

> `WIP:` Нейминг групп временный, и будет определен окончательно ближе к релизу MVP

<!-- TODO: Надо позже будет всеж определиться - куда это класть, и как называть (абстракции ли?) -->

```sh
└── src/
    ├── app/                    # Layer: Приложение
    |                           #
    ├── processes/              # Layer: Процессы (опционален)
    |   ├── {some-process}/     #     Slice: (н-р процесс CartPayment)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (хелперы)
    |   |   └── model/          #         Segment: Бизнес-логика
    |   ...                     #
    |                           #
    ├── pages/                  # Layer: Страницы
    |   ├── {some-page}/        #     Slice: (н-р страница ProfilePage)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (хелперы)
    |   |   ├── model/          #         Segment: Бизнес-логика
    |   |   └── ui/             #         Segment: UI-логика
    |   ...                     #
    |                           #
    ├── features/               # Layer: Фичи
    |   ├── {some-feature}/     #     Slice: (н-р фича AuthByPhone)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (хелперы)
    |   |   ├── model/          #         Segment: Бизнес-логика
    |   |   └── ui/             #         Segment: UI-логика
    |   ...                     #
    |                           #
    ├── entities/               # Layer: Бизнес-сущности
    |   ├── {some-entity}/      #     Slice: (н-р сущность User)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (хелперы)
    |   |   ├── model/          #         Segment: Бизнес-логика
    |   |   └── ui/             #         Segment: UI-логика
    |   ...                     #
    |                           #
    ├── shared/                 # Layer: Переиспользуемые ресурсы
    |   ├── api/                #         Segment: Логика запросов к API
    |   ├── lib/                #         Segment: Инфраструктурная-логика (хелперы)
    |   └── ui/                 #         Segment: UI-логика
    |   ...                     #
    |                           #
    └── index.tsx/              #
```

---

## Предисловие

Любой проект не живет в статике, и со временем только обрастает сложностью, новыми участниками и требованиями.

<details>
<summary>При этом из проекта в проект кочуют одни и те же абстракции (хоть и порой под разными именами)</summary>

> - `screens` / `pages` / `layouts`
> - `core` / `app`
> - `shared` / `common` / `lib`
> - `ui` / `components`
> - `model` / `store` / `state`
> - `api` / `services`
</details>

Где-то хватает базового набора сущностей (таких как страницы, хелперы, компоненты), а где-то сущности добавляются налету - чтобы зарезолвить ту или иную возникшую проблему.
> О стандартизации структур говорить не приходится...

**Методология призвана решить эти вопросы.**

В результате обсуждений и слияния опытов - *было принято решение разделять проекты следующим образом*

<details>
<summary>Про строгий нейминг</summary>

Отдельной проблемой для core-team - было прийти к единому неймингу сущностей
> Очевидно, что каждый привык называть по-своему, даже учитывая что у всех в голове `feature-based` подход к структуре

И создавалось немало тредов (как минимум [общий][disc-poll], [про процессы][disc-processes], [про модели][disc-model]) - с главным вопросом: **"как же нам назвать сущности, чтобы пользователю не захотелось их переименовать?"**
> [Мы приняли строгую позицию, касаемо адаптивности нейминга][ref-naming-adaptability] - чтобы в feature-sliced проектах была та самая стандартизация, которой не хватает в мире фронтенда

В итоге, путем трейдоффов и обсуждений - пришли к тому варианту, который расписан ниже
</details>

## Group: `Layers`
Первый уровень разделения: по **скоупу влияния** модуля

> **Самопроверка**: *"К какому слою приложения относится модуль?"*

```sh
└── src/
    ├── app/                    # Инициализирующая логика приложения
    ├── processes/              # (Опц.) Процессы приложения, протекающие над страницами
    ├── pages/                  # Страницы приложения
    ├── features/               # Ключевой функционал приложения (разбитый по фичам)
    ├── entities/               # Бизнес-сущности
    └── shared/                 # Переиспользуемые модули
```

<details>
<summary>Про порядок слоев</summary>

<!-- FIXME Возможно это уже где-то есть, но я упорно не могу найти доку -->

Если посмотреть на порядок слоев - то можно выделить две последовательности:
1. **По уровню знания/ответственности**
    > Модуль "знает" только про себя и нижележащие модули, но не выше лежащие
    >
    > Это же влияет и на разрешенные импорты
    > - `app > *processes > ... > entities > shared`
2. **По уровню опасности изменений**
    > Чем ниже расположен модуль - тем опаснее вносить в него изменения
    >
    > Т.к. скорее всего он заиспользован во многих вышележащих слоях
    > - `shared > entities > ... > *processes > app`

</details>

## Group: `Slices`
Второй уровень разделения: по **конкретной функциональности БЛ**

*Методология не влияет на этот уровень и все крайне зависит [от конкретного проекта][disc-usability]*

> **Самопроверка**: *"Какую область БЛ затрагивает модуль?"*
> 
> *До этого - надо определится со скоупом влияния (layer)*

```sh
├── app/
|   # Не имеет конкретных слайсов, 
|   #   т.к. там содержится мета-логика над проектом
├── processes/
|   # Слайсы для реализации процессов на страницах
|   ├── cart-payment
|   ├── auth
|   └── ...
├── pages/
|   # Слайсы для реализации страниц приложения
|   ├── profile
|   ├── sign-up
|   ├── feed
|   └── ...
├── features/
|   # Слайсы для реализации конкретной функциональности на страницах
|   ├── auth-by-phone
|   ├── inline-post
|   └── ...
├── entities/
|   # Слайсы бизнес-сущностей для реализации более сложной БЛ
|   ├── viewer
|   ├── posts
|   ├── i18n
|   └── ...
└── shared/
    # Сам по себе представляет слайс, 
    #   т.к. здесь только переиспользуемые модули, без привязки к БЛ
```

## Group: `Segments`
Третий уровень разделения: по **назначению модуля в коде и реализации**

> **Самопроверка**: *"Какую часть тех. реализации логики затрагивает модуль?"*
> 
> *До этого - надо определится со скоупом влияния (слой) и доменной принадлежностью (слайсом)*

```sh
{layer}/
    ├── {slice}/
    |   ├── ui/                     # UI-логика (components, ui-widgets, ...)
    |   ├── model/                  # Бизнес-логика (store, actions, effects, reducers, ...)
    |   ├── lib/                    # Инфраструктурная логика (utils/helpers)
    |   └── api/                    # Логика запросов к API (api instances, requests, ...)
```

<details>
<summary>Про разрешенные <code>segments</code> для <code>layers</code></summary>

Конечно, хочется, чтобы **любой из перечисленных выше сегментов** можно было положить внутри слайса **любого слоя**

Однако [опыт и дискуссии][disc-list] показали, что лучше и логичнее ограничить каждый слой на используемые внутри сегменты

**Общие правила:**
- (\*) Чем выше расположен слой - тем больше он знает про БЛ приложения и наоборот
- (\*\*) API логику *рекомендуется* класть в `shared`, чтобы не распылялась по проекту
    > Как правило - она общая и представлена в виде единых инстансов
    >
    > **Edge-cases**: *GraphQL*, *react-query hooks*

**Для конкретных слоев:**
1. `app`: Обычно не включает в себя слайсы и содержит логику инициализации
    > Имеющиеся сегменты не совсем подходят, а потому используются обычно `/hocs`, `/styles` и т.д.
    > 
    > Очень зависит от проекта и вряд ли решается методологией
2. `processes`: Обычно слайсы внутри включают в себя только бизнес-логику, без отображения (\*)
    > Разрешенные сегменты: `lib`, `model`, `**api`
3. `pages`: Обычно слайсы внутри включают в себя ui- и model- композицию различных фичей для конкретной страницы
    > Разрешенные сегменты: `ui`, `lib`, `model`, `**api`
4. `features`: Обычно слайсы внутри включают в себя композицию сущностей и реализацию БЛ в модели + отображение
    > Разрешенные сегменты: `ui`, `lib`, `model`, `**api`
5. `entities`: Обычно слайсы внутри представляют разрозненный набор подмодулей для использования
    > Разрешенные сегменты: `ui`, `lib`, `model`, `**api`
6. `shared`: Обычно содержат только инфраструктурную логику без БЛ \*)
    > Разрешенные сегменты: `ui`, `lib`, `api`

</details>

## См. также
- [Обсуждение **"Абстракции методологии, их цели и нейминг"**][src-disc]
- **Обсуждения по неймингу сущностей**
    - [Опрос по неймингу][disc-poll]
    - [`processes` vs `flows` vs ...][disc-processes]
    - [`model` vs `store` vs ...][disc-model]
- [Первичное описание абстракций][tg-description]
- [Статья **"Про разбиение приложения"**][ref-app-splitting]
