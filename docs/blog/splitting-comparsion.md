[disc-src]: https://github.com/feature-sliced/documentation/discussions/31#discussioncomment-45150-src7
[ref-motivation]: /docs/get-started/motivation.md
[ext-pluralsight]: https://www.pluralsight.com/guides/how-to-organize-your-react-+-redux-codebase
[ext-medium]: https://alexmngn.medium.com/why-react-developers-should-modularize-their-applications-d26d381854c1
[ext-ryanlanciaux]: https://ryanlanciaux.com/blog/2017/08/20/a-feature-based-approach-to-react-development/
[ext-react]: https://reactjs.org/docs/faq-structure.html

# Разбиение приложения

> О способах разбиения проекта по модулям и позиции методологии

---

## `TL;DR:`

> `WIP:` Нейминг групп временный, и будет определен окончательно ближе к релизу MVP

- *Методология рекомендует разбивать проект следующим образом:*
    1. *Сначала по **слоям** - согласно скоупу влияния модуля*
        > `app`, `processes`, `pages`, `features`, `entities`, `shared`
    2. *Затем по **слайсам** - согласно конкретной функциональности БЛ*
        > *Нейминг очень зависит от конкретного проекта*
    3. *И наконец **сегментам** - согласно назначению модуля в коде и реализации*
        > `ui`, `model`, `api`, `lib`

- *Структура приложения должна помогать внедрять новых людей, предсказуемо вносить изменения и развивать проект, в условиях постоянно меняющихся требований*

- *Разбиение согласно методологии - [в конце статьи](#структура)*

---

## Предистория

Каждый из нас застал на своем пути проекты примерно такой структуры

```sh
└── src/
    ├── api/
    ├── components/
    ├── containers/
    ├── helpers/
    ├── pages/
    ├── store/
    └── index.tsx/
```

<details>
<summary>Ведь на первый взгляд - такой подход кажется простым</summary>

- Все лежит на верхнем уровне
    > Нет глубокой вложенности и длинным импортам!
- В каждом модуле конкретно понятно что лежит, по его прямому назначению
    > В store - все экшены/редьюсеры/эффекты приложения, в хелперах - все хелперы и т.д.

И более того - каждый из нас, поначалу, создавал проекты с такой структурой!

*Особенно если мы говорим про React*
</details>

> *(\*) Запомним эту конструкцию, и вернемся к ней позднее*

## Жизненный цикл проекта

<!-- 
TODO Возможно даже имеет смысл вынести в отдельную доку
Хотя изначально писал именно для `app-splitting`
-->

Проекты не живут в статике. Они постоянно развиваются и дополняются требованиями, новой функциональностью.

При этом мы не знаем новые требования наперед - и это тоже вызывает проблемы, при структурировании модулей

**Потому хочется, чтобы архитектура и структура приложения - позволяла масштабировать кодовую базу и комманду - с наименьшими негативными последствиями для проекта**

<details>

### Вот в чем беда

- Обычно изначально проект разрабатывается под изначальный слепок требований с определенным контекстом
    > Если мы попытаемся добавить новые/изменить прежние - поначалу еще как-то удается их вписать в существующую архитектуру
    >
    > Но скорей всего - *если архитектура приложения не заточена под изменения в функциональности - кодобаза превратится в спагетти-код*, который будут понимать только те, кто стояли у истоков

- У нас, разработчиков, нет "шара предвидения". Тем не менее мы постоянно пытаемся что-то предсказать
    >
    > - какой модуль будет переиспользован в дальнейшем (а может вынести все в shared?),
    > - где добавить прослойку для уменьшения прямой связности модулей
    > - и т.д.

### Последствия

- И из-за этого, обычно, проект - это **большой набор костылей, подпирающих динамически меняющаяся функциональность**
    > Будь то A/B тесты, или же просто новый пласт требований - который "плохо кладется" под имеющуюся архитектуру

- Ситуация становится еще "веселее", **когда старый код уже настолько покрылся мхом - что начинают сыпаться баги из-за регрессий и высокой связности**

    А поскольку о модуляризации и изолированности изначально чаще всего никто не хотел/не успел подумать - нет возможности взять и отрефакторить начисто только один модуль
    > В некоторых случаях это может даже загубить проект, если не соблюдаются практики код-ревью, рефакторинга и покрытия тестами

- По итогу, чаще всего, **получаем то, чего хотели избежать в проекте**
    >
    > - Оверсложность
    > - Непредсказуемость
    > - Конфликты при добавлении изменений
    > - Cложность в освоении новыми людьми
    > - и т.д.

</details>

## Как быть?

<!--TODO Можно наверное даже потом вынести в отдельную доку "Парадокс Провидца" -->

> Я думаю мало кто из нас может похвастаться талантом "провидца", и разделять модули в приложении под будущие изменения корректно

**А потому, нам - разработчикам - стоит принять следующее:**

1. Контекст разработки и доменной области каждого конкретного проекта - равен нулю в начале, и увеличивается только с развитием проекта
    > Т.е. мы в подавляющем большинстве случаев не знаем *куда положить определенную фичу, какой модуль может быть переиспользован в будущем для приложения и т.д.*
2. Проект постоянно будет меняться, а потому - лучше изначально готовить архитектуру **к возможным изменениям**
    > *При этом важен баланс*: возможно, не стоит добавлять прослойку для работу с API "на будущее"
    >
    > Однако логика должна быть распределена так - чтобы мы могли завтра ее *относительно легко* дополнить/переиспользовать или же вообще удалить и написать именно эту часть по-новой

## Подходы к структуризации

Вернемся к структуризации.

**Очень хочется, чтобы структура и архитектура проекта позволяла бы снизить негативное влияние перечисленных выше проблем**

Но увы - на данный момент в мире фронтенда нет каких-то устоявшихся подходов, которые бы встречались из проекта в проект
> Да, у нас есть принципы `Separation of Concerns`, есть `DDD`, есть `SOLID` и т.д.
>
> И даже их каждый [интерпретирует *по-своему*][ref-motivation] - и это еще одна *проблема*

**Однако если отбросить детали - можно условно выделить два базисных подхода к структуризации**

> *Понятно, что структура для конкретного проекта - скорее комбинация / адаптация этих вариантов*

### `1. Flat Structure`

> *FIRST by-types, THEN by-domains*

Помните изначальную структуру (*)? Обычно ее называют "плоской"

- **Сначала - идет разделение по типам**
- **Затем - по доменам**

<details>
<summary>Пример структуры</summary>

```sh
└── src/
    ├── api/            # API приложения для конкретных доменов
    |   ├── users/
    |   └── posts/
    ├── ui/             # UIKit
    ├── containers/     # Контейнеры (упаси бог) для конкретных доменов
    |   ├── users/
    |   └── posts/
    ├── helpers/        # Хелперы для конкретных доменов
    |   ├── users/
    |   └── posts/
    ├── pages/          # Страницы для конкретных доменов
    |   ├── users/
    |   └── posts/
    ├── store/          # Store-логика доменов
    |   ├── users/
    |   └── posts/
    └── index.tsx/
```

> Заметьте, что чаще всего одни и те же сущности/фичи - повторяются на внутреннем уровне верхних модулей

</details>

<details>
<summary>Плюсы/Минусы</summary>

- `+` Низкая вложенность, облегчает импорты
- `+` Легко реализовать для простых проектов
- `-` Сложно "прочитать" проект, при добавлении новых людей в команду
    > Так называемые `discoverability` и `navigation-in-project`
- `-` Идет упор на "технологичное применение" модуля, а не на "функциональное"
    > Из-за чего сложно "прочитать" проект и поддерживать связи меж модулями в желаемом состоянии
- `-` Логика **размыта** по всему проекту
    > Из-за чего при внесении изменений в проект - она разбивается сразу на все директории на верхнем уровне
    >
    > Помимо того, что это может привести к конфликтам - это гораздо сложней вычитывать и дебажить
- `-` Сложно избавиться от **сильной связности** модулей
    > Что ведет к непредсказуемому взаимодействию модулей друг на друга
- `-` Сложно поддерживать модули, при росте кодовой базы
    > Особенно увидеть и гарантировать - где используются, например контейнеры для постов
    >
</details>

### `2. Domain Based Structure`

> *FIRST by-domains, THEN by-types*

А теперь попробуем наоборот

- **Сначала - идет разделение по доменам**
- **Затем - по типам**

<details>
<summary>Пример структуры</summary>

```sh
└── src/
    ├── ui/             # Общий UIKit, без привязки к БЛ
    ├── helpers/        # Общий набор хелперов, без привязки к БЛ
    ├── posts/          # Функциональность постов (со всеми необходимыми ресурсами)
    |   ├── (api/)
    |   ├── ui/
    |   ├── store/
    |   ├── helpers/
    |   ├── (pages/)
    |   └── posts/
    ├── users/          # Функциональность пользователей (со всеми необходимыми ресурсами)
    |   ├── (api/)
    |   ├── ui/
    |   ├── store/
    |   ├── helpers/
    |   ├── (pages/)
    |   └── posts/
    └── index.tsx/
```

> Заметьте, что да - теперь у нас все повторяется внутри сущностей, однако теперь каждая "фича" содержит в себе все что нужно
>
> И исправляя что-то в функциональности `users`, вы затрагиваете только эту директорию и не больше!

</details>

<details>
<summary>Плюсы/Минусы</summary>

- `+` Легко добавлять/изменять функциональность
    > Просто добавить/подправить отдельную папку - без влияния на другие
- `+` Каждая фича содержит в себе только то что нужно
    > Нет ничего лишнего, сразу видно все используемое в фиче
    >
    > В том числе - это упрощает модель (*store) самой фичи
- `+` Модули изолированы друг от друга
    > Что **значительно** помогает в разработке и исправлении ошибок
- `+` Логика распределена по фичам(доменам), а не по всему проекту
    > Что упрощает изучение проекта и навигацию по нему
    >
    > И разработку - в том числе
- `+` Легко расширять команду
    > Можно выделить команду/конкретных людей на отдельные фичи(домены) - и они смогут вести разработку независимо друг от друга, с наименьшим числом конфликтов
    >
    > А также - гораздо легче изучать сам проект (например не весь сразу - а только конкретную функциональность)
- `+` Проект становится масштабируемым, поддерживаемым и читабельным
- `-` Требуется много усилий, чтобы оставлять фичи изолированными
    > Это в целом, достаточно давний вопрос
    >
    > Но обычно - дело решается добавлением новых абстракций (processes/entities)
    >
    > Хоть и требуется доп. код, для поддержания изолированности - бенефиты от этого все равно перевешивают
- `-` Структура чаще всего - становится слишком вложенной
- `-` Иногда сложно выделить - куда положить логику кода для pages, для виджета, для конкретной сущности и т.д.

</details>

## Позиция методологии

Очевидно - мы склоняемся больше к domain-based подходу.

*Однако понятно, что у него есть свои проблемы*

А потому, методология вводит дополнительный верхний уровень абстрагирования - **для распределения модулей по скоупу и контексту влияния**
> `app` > `processes` > `pages` > `features` > `entities` > `shared`

### Разделение

> `WIP:` Нейминг групп временный, и будет определен окончательно ближе к релизу MVP

В целом, методология опирается на уже привычные способы разделения логики

> При этом, приходится вводить свой нейминг, для более корректного обозначения каждой группы абстракций

1. **Группа абстракций `layers`: на уровне распределенных скоупов логики приложения**
    > `app`, `*processes`, `pages`, `features`, `*entities`, `shared`
2. **Группа абстракций `slices`: на уровне конкретной функциональности БЛ**
    > Все, что связно с бизнес-логикой вашего приложения для данной абракции фичи:
    >
    > - (processes) `auth`, `payment`, ...
    > - (features) `auth-by-phone`, `pay-by-card`, `inline-post`, ...
    > - (entities) `user`, `post`, `task`, ...
    > - ...
    >
3. **Группа абстракций `segments`: на уровне конкретного назначения модуля в коде**
    > `ui`, `model`, `lib`, `*api`

<details>
<summary>По структуре можно отследить...</summary>

- Сначала идет разделение по **слоям**
  > это код для приложения/процесса/страницы/фичи/... ?
- Затем подбирается конкретный **слайс** (aka *domain*)
  > в зависимости от БЛ приложения
- И наконец - выбирается **сегмент** (aka *module type*)
  > в зависимости от технического назначения - UI/BL/Utils/...
  >
</details>

<details>

<summary>Иными словами...</summary>

Разделение по доменам(фичам) - замечательно

Но когда все домены лежат в куче в руте - среди этого сложно ориентироваться

<!-- FIXME: Возможно где-то эта инфа уже есть, я найти не могу -->

**Еще сложнее, управлять грамотно скоупом "знания" и "опасности изменений"**

А так, мы явно задаем правила из структуры:

1. Модуль "знает" только про себя и нижележащие модули, но не выше лежащие
    > **По уровню знания/ответственности**
    >
    > - `app > *processes > ... > entities > shared`
    >
2. Чем ниже расположен модуль - тем опаснее вносить в него изменения
    > Т.к. скорее всего он заиспользован во многих вышележащих местах
    >
    > **По уровню опасности изменений**
    >
    > - `shared > entities > ... > *processes > app`

Таким образом - каждая группа абстракций служит для своих целей, и при этом позволяет на уровне конвенций распределять код
</details>

### Структура

<!-- TODO: Надо уже какую-нить тулзу для динамической доки подтянуть, а то одну и ту же структуру меняю в трех в файлах постоянно -->

```sh
└── src/
    ├── app/                    # Layer: Приложение
    |                           #
    ├── processes/              # Layer: Процессы (опционален)
    |   ├── {some-process}/     #     Slice: (н-р процесс CartPayment)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (хелперы)
    |   |   └── model/          #         Segment: Бизнес-логика
    |   ...                     #
    |                           #
    ├── pages/                  # Layer: Страницы
    |   ├── {some-page}/        #     Slice: (н-р страница ProfilePage)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (хелперы)
    |   |   ├── model/          #         Segment: Бизнес-логика
    |   |   └── ui/             #         Segment: UI-логика
    |   ...                     #
    |                           #
    ├── features/               # Layer: Фичи
    |   ├── {some-feature}/     #     Slice: (н-р фича AuthByPhone)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (хелперы)
    |   |   ├── model/          #         Segment: Бизнес-логика
    |   |   └── ui/             #         Segment: UI-логика
    |   ...                     #
    |                           #
    ├── entities/               # Layer: Бизнес-сущности
    |   ├── {some-entity}/      #     Slice: (н-р сущность User)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (хелперы)
    |   |   ├── model/          #         Segment: Бизнес-логика
    |   |   └── ui/             #         Segment: UI-логика
    |   ...                     #
    |                           #
    ├── shared/                 # Layer: Переиспользуемые ресурсы
    |   ├── api/                #         Segment: Логика запросов к API
    |   ├── lib/                #         Segment: Инфраструктурная-логика (хелперы)
    |   └── ui/                 #         Segment: UI-логика
    |   ...                     #
    |                           #
    └── index.tsx/              #
```

### Ограничение на абстракции

<!-- Возможно, стоит продублировать и в других доках -->

Учитывая вышесказанное - разумно **ограничить** использование каждой группы в пути файла *до максимум одного раза*

```sh
# Dirname:
{layer}/{slice}/{segment}/...

# Для shared нет слайсов - т.к. там располагаем переиспользуемую логику
# Без привязки к БЛ
# (он сам по себе - скорее как единый слайс)
- {shared}/{-}/{ui}/button
- {entities}/{viewer}/{lib}/use-auth
- {features}/{auth-by-phone}/{ui}/...
- {pages}/{profile}/{model}
- ...
```

> Так пропадают все вопросы типа
>
> - `А могут ли быть вложенные фичи?`
> - `А может ли быть entity внутри page?`
> - и т.д.

## См. также

- [(Тред) - Про разбиение приложения][disc-src]
- [(Статья) Про организацию кодовой базы *с полным сравнением нескольких подходов*][ext-pluralsight]
- [(Статья) Про модуляризацию проектов][ext-medium]
- [(Статья) Про Separation of Concerns и структурирование по фичам][ext-ryanlanciaux]
- [Документация от React - О двух способах разделить приложение][ext-react]
- [Глоссарий методологии](/docs/reference/knowledge-types.md)
