[src-disc]: https://github.com/feature-sliced/wiki/discussions/43
[src-tg]: https://t.me/atomicdesign/18972
[refs-arch--adaptability]: ./architecture.md#adaptability-адаптивностькастомизируемость
[refs-medium-article]: https://alexmngn.medium.com/how-to-better-organize-your-react-applications-2fd3ea1920f1
[discussions]: https://github.com/feature-sliced/wiki/discussions

# О понимании потребностей и формулировке задач

> О задачах пользователей, бизнеса, построении функциональности и как в этом помогает методология
---
## `TL;DR:`

— *Не получается сформулировать цель, которую будет решать новая фича? А может проблема в том, что сама задача не сформулирована? **Смысл ещё и в том, чтобы методология помогла вытащить наружу проблемное определение задач и целей***

— *Проект не живет в статике - требования и функциональность постоянно меняются. Со временем, код превращается в кашу, т.к. на старте проект был спроектирован только под изначальный слепок пожеланий. **И задача хорошей архитектуры в том числе - чтобы быть заточенной под изменяющиеся условия разработки.***

---

<!--TODO: Сделать каждый раздел позднее более самостоятельным сам по себе -->
<!--TODO: Добавить больше информации по изменяющимся требованиям проекта -->

## Зачем?

Чтобы подобрать четкое имя сущности и понять ее составляющие, **нужно отчетливо понимать - какая задача будет решена с помощью всего этого кода.** 

<details>

Во время разработки, мы пытаемся *каждой сущности или функции дать имя, которое четко отражает намерения и смысл выполняемого кода.* 

> Фраза "программа делает не то, что хотел разработчик, а что он написал", отлично отражает проблему плохого именования

</details>

*Ведь, без понимания задачи, нельзя написать правильные тесты, покрывающие самые важные кейсы, проставить ошибки помогающие пользователю в нужных местах, даже банально не прерывать флоу пользователя из-за исправимых не критичных ошибок.*

## О каких задачах речь?

*Frontend занимается разработкой приложений и интерфейсов для конечных пользователей, значит мы решаем задачи этих потребителей.*

Когда к нам приходит человек, **он хочет решить какую-то свою боль или закрыть потребность.**

*Задача менеджеров и аналитиков - сформулировать эту потребность, а разработчиков реализовать с учетом особенностей веб-разработки (потеря связи, ошибка бекенда, опечатка, промазал курсором или пальцем).*

<details>

Команда производства веб-сервисов специально разделяется на *аналитиков, менеджеров, дизайнеров, разработчиков и прочих*

Каждый используя свой опыт проектирует часть задачи, в которой он лучше разбирается:
- **Дизайнеры** понимают пользовательский опыт с точки зрения визуального интерфейса, иногда даже разбираются в проблемах веб-интерфейсов, за что отдельный плюс. 
- **Разработчики** понимают как не потерять пользователя из-за своих же багов, проблем с интернетом или медленным устройством.

*Каждый в этой большой команде помогает пользователю решать свою задачу эффективнее, потому что пользователь пришёл к "нам" за решением своей боли, а не получением новой.*

> Очень плохо *прийти в сервис, чтобы решить проблему* автоматизации создания новых событий в ленте, *а получить боль* из-за необходимости каждый раз их вручную подтверждать, потому что дизайнеры или разработчики не подумали о целях пользователя, зачем собственно он пришёл на сервис.
</details>

**Эта самая цель, с которой пришёл пользователь и есть задача разработчиков.**

> *Одна маленькая решенная задача и есть feature в методологии feature-sliced — нужно нарезать весь скоуп задач проекта на маленькие цели.*

## Как это влияет на разработку?

- Когда разработчик принимается реализовывать задачу, он мысленно **нарезает ее на этапы**:
    - сначала *разбить на верхнеуровневые сущности* и *реализовать их*, 
    - затем эти сущности *разбить на более мелкие* 
    - и так далее

    > *Все для упрощения понимания и поддержки кода*, а следовательно - и написания тестов.

    <details>

    В обратную сторону тоже можно, хоть и гораздо сложнее, ведь сначала придётся придумать и реализовать низкоуровневые сущности и библиотеки, а потом их как-то складывать между собой, не забыв при этом реализовать целевую задачу.

    *В процессе разбиения на сущности, разработчик вынужден дать им название, которое четко отражало бы его замысел и при чтении листинга помогало понять какую задачу решает код*
    > А мы помним, что пытаемся помочь пользователю уменьшить боль или реализовать потребности
    </details>

- Но чтобы дать четкое название сущности, **разработчик должен знать предостаточно о ее назначении**...
    <details>

    - как он собирается использовать эту сущность, 
    - какую часть задачи пользователя она реализует, где ещё эту сущность можно применить, 
    - в каких ещё задачах она может поучаствовать, 
    - и так далее

    > Это все вопросы в одной плоскости, и они крутятся в фоне в процессе размышления.
    </details>

Сделать вывод не сложно: **пока разработчик будет размышлять над названием сущностей в рамках методологии, он сможет найти плохо сформулированные задачи ещё до написания кода.**

> Как дать название сущности, если плохо понимаешь, какие задачи она может решать, как вообще можно разбить задачу на сущности, если плохо ее понимаешь?

## Как сформулировать?

*Чтобы сформулировать задачу, которая решается фичей, нужно понимать саму задачу*, а это уже область ответственности менеджера проекта и аналитиков. 

> Методология может лишь *подсказать разработчику, на какие задачи стоит обратить пристальное внимание менеджеру продукта.*

<details>

Весь frontend это в первую очередь отображение информации, любой компонент в первую очередь что-то отображает, а значит задача "показать пользователю что-то" не имеет практической ценности. 

Даже без учета специфики frontend можно спросить "а зачем это нужно показывать", так можно продолжать спрашивать до тех пор пока не вылезет боль или потребность потребителя. 

> Их не так много:
> - "я не хочу тратить время или деньги"
> - "я хочу заработать деньги, время или эмоции", 
>
> Можно ещё пару сформулировать если хочется, но обычно бизнес основывается на этом
</details>

Как только мы смогли дойти до базовых потребностей или болей, можно идти обратно и разбираться, **а как именно ваш продукт или сервис может помочь пользователю с его целями**

<details>

> Будет ли это сервис, 
> - который поможет пользователю тратить меньше времени на его задачи, 
> - или же будет приносить ему удовольствие от процесса, 
> - или же это будет услуга, улучшающая его отношения с женой
>
> Здесь все зависит от целей бизнеса для которого вы разрабатываете продукт.
</details>

**Любая новая задача в вашем трекере направлена на решение задач бизнеса, а бизнес пытается решить задачи пользователя одновременно заработав на нём.** А значит, каждая задача несёт в себе определенные цели, даже если они не прописаны в тексте описания. 

> *Разработчик должен четко понимать, какую цель преследует та или иная задача*, но при этом не каждая компания может позволить себе идеально выстроить процессы, хоть это и отдельный разговор, тем не менее, разработчик вполне может сам "пингануть" нужных менеджеров, чтобы выяснить это и сделать свою часть работы эффективно.

## А какой профит?

- Основная цель — **понимание задач пользователей**
    <details>

    Когда разработчик понимает его боли и то, как бизнес их закрывает, он может предлагать решения, которые бизнесу не доступны в силу специфики веб-разработки. 

    > Но конечно, все это может работать только если разработчику небезразлично то, что он делает и ради чего, а иначе *зачем тогда методология и какие-то подходы?*
    </details>

- С пониманием задач приходит **четкая структура как в голове, так и в задачах вместе с кодом**
- Становится также ясно - **что есть фича и из чего она может состоять**
    <details>

    Одна фича - это одна полезная функциональность для пользователя
    > Когда в одной фиче - реализуется несколько - это и есть нарушение границ

    Фича может быть неделимой и разрастающейся - **и это неплохо**

    **Плохо** - когда фича не отвечает на вопрос *"а в чем бизнес-ценность для пользователя?"*

    > - Не может быть фичи `карта-офиса`
    > - А вот `бронирование-переговорки-на-карте`, `поиск-сотрудника`, `смена-рабочего-места` - **да**
    >
    > Это уже три фичи, основанные на карте офиса - они маленькие, как и код реализующий эту карту

    Смысл в том, чтобы *в фиче лежал только код, реализующий непосредственно саму функциональность*, без лишних подробностей и внутренних решений (в идеале)
    > Открываешь код фичи **и видишь только то, что относится к задаче** - не больше
    </details>

Бизнес крайне редко разворачивает свой курс кардинально в другую сторону, а значит **отражение задач бизнеса в коде frontend приложения это весьма существенный профит.**

> *Тогда не придётся объяснять каждому новому члену команды, что делает тот или иной код, и вообще ради чего он добавлялся - **все будет объясняться через задачи бизнеса, которые уже отражены в коде.***

<details>
<summary>
То, что называется "Язык бизнеса" в Domain Driven Development
</summary>

Отчасти это разговор о `bounded context`, который имеет прямую связь между бизнес потребностями/сущностями, которыми он оперирует и тем как будет построено приложение
</details>

---

## Но реальность сурова...
Если бизнес процессы осмыслены и на стадии дизайна даны хорошие имена - *то перенести это понимание и логику в код не особо проблемно.* 

В реальности же - задачи и функциональность развиваются "слишком" итеративно и (или) нет времени продумывать дизайн.

**В итоге фича сегодня имеет смысл, а при расширении этой фичи через месяц можно пол проекта переписать.**

<details>
<summary>Пробуем предугадать будущее...</summary>

Разработчик пытается думать на 2-3 шага вперед, учитывая будущие хотелки, но тут упирается в собственный опыт

- Проженный опытом инженер обычно сразу смотрит на 10 шагов вперед, и понимает где одну фичу разделить, а где объединить с другой

- Но бывает и так, что приходит задача, с которой не приходилось сталкиваться по опыту, и неоткуда взять понимание - как грамотней декомпозировать, с наименьшими печальными последствиями в будущем
</details>

## Роль методологии
**Методология помогает решить проблемы разработчиков, чтобы тем было проще решать проблемы пользователей.**

> *Нет решения задач разработчиков только ради разработчиков*
>
> *Но чтобы разработчик решил свои задачи, **нужно понять задачи пользователя** - наоборот не выйдет*

Становится ясно, что нужно выделить как минимум два требования для **feature-sliced**:
1. Методология должна рассказывать *как создавать фичи, процессы и сущности*
    > А значит должна четко объяснять *как разделять код между ними*, из чего следует, что именование этих сущностей также должно быть заложено в спецификации. 
2. Методология должна помогать архитектуре *легко адаптироваться под изменяющиеся требования проекта*
    > См. [требования к хорошей архитектуре - `adaptability/flexibility`][refs-arch--adaptability]

## См. также
- [*Обсуждение* "Стимуляция к четкой формулировке задач"][src-disc]
- [*Начало обсуждения* "Как разбить функциональность и что из себя она представляет"][src-tg]
- [*Статья* "How to better organize your applications"][refs-medium-article]
