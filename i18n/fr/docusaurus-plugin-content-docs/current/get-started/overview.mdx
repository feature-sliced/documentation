---
sidebar_position: 1
---

# AperÃ§u

**Feature-Sliced Design** (FSD) est une mÃ©thodologie architecturale pour la structure des applications front-end. En termes simples, c'est un ensemble de rÃ¨gles et de conventions sur l'organisation du code. Le principal objectif de cette mÃ©thodologie est de rendre le projet plus comprÃ©hensible et stable face aux exigences commerciales en constante Ã©volution.

Outre un ensemble de conventions, FSD est Ã©galement un ensemble d'outils. Nous avons un [linter][ext-steiger] pour vÃ©rifier l'architecture de votre projet, des [gÃ©nÃ©rateurs de dossiers][ext-tools] via un CLI ou des IDE, ainsi qu'une riche bibliothÃ¨que [d'exemples][examples].

## Est-ce fait pour moi ? {#is-it-right-for-me}

FSD peut Ãªtre mis en Å“uvre dans des projets et des Ã©quipes de toutes tailles. Il est adaptÃ© Ã  votre projet si :

- Vous travaillez sur le **frontend** (UI sur web, mobile, bureau, etc.)
- Vous construisez une **application**, pas une bibliothÃ¨que

Et c'est tout ! Il n'y a aucune restriction sur le langage de programmation, le framework UI ou le gestionnaire d'Ã©tat que vous utilisez. Vous pouvez Ã©galement adopter FSD de maniÃ¨re incrÃ©mentielle, l'utiliser dans des monorepos et l'Ã©tendre en divisant votre application en packages et en appliquant FSD individuellement dans chacun d'eux.

Si vous avez dÃ©jÃ  une architecture en place et que vous envisagez de passer Ã  FSD, assurez-vous que l'architecture actuelle **pose problÃ¨me** dans votre Ã©quipe. Par exemple, si votre projet est devenu trop grand et trop interconnectÃ© pour implÃ©menter efficacement de nouvelles fonctionnalitÃ©s, ou si vous attendez beaucoup de nouveaux membres dans l'Ã©quipe. Si l'architecture actuelle fonctionne, il n'est peut-Ãªtre pas nÃ©cessaire de la changer. Mais si vous dÃ©cidez de migrer, consultez la section [Migration][migration] pour obtenir des conseils.

## Exemple de base {#basic-example}

Voici un projet simple qui implÃ©mente FSD :

- `ğŸ“ app`
- `ğŸ“ pages`
- `ğŸ“ shared`

Ces dossiers de niveau supÃ©rieur sont appelÃ©s _couches_. Voyons plus en dÃ©tail :

- `ğŸ“‚ app`
   - `ğŸ“ routes`
   - `ğŸ“ analytics`
- `ğŸ“‚ pages`
   - `ğŸ“ home`
   - `ğŸ“‚ article-reader`
      - `ğŸ“ ui`
      - `ğŸ“ api`
   - `ğŸ“ settings`
- `ğŸ“‚ shared`
   - `ğŸ“ ui`
   - `ğŸ“ api`

Les dossiers Ã  l'intÃ©rieur de `ğŸ“‚ pages` sont appelÃ©s _tranches_. Ils divisent la couche par domaine (dans ce cas, par pages). 

Les dossiers Ã  l'intÃ©rieur de `ğŸ“‚ app`, `ğŸ“‚ shared`, et `ğŸ“‚ pages/article-reader` sont appelÃ©s _segments_, et ils divisent les tranches (ou les couches) par objectif technique, c'est-Ã -dire Ã  quoi sert le code.

## Concepts {#concepts}

Les couches, les tranches et les segments forment une hiÃ©rarchie comme suit :

<figure>
   ![HiÃ©rarchie des concepts de FSD, dÃ©crite ci-dessous](/img/visual_schema.jpg)

   <figcaption style={{ fontStyle: "italic", fontSize: "0.9em" }}>
      <p>Illustration ci-dessus : trois piliers, Ã©tiquetÃ©s de gauche Ã  droite comme "Couches", "Tranches" et "Segments".</p>
      <p>Le pilier "Couches" contient sept divisions disposÃ©es de haut en bas et Ã©tiquetÃ©es "app", "processes", "pages", "widgets", "features", "entities", et "shared". La division "processes" est barrÃ©e. La division "entities" est reliÃ©e au deuxiÃ¨me pilier "Tranches" de maniÃ¨re Ã  indiquer que ce pilier est le contenu de "entities".</p>
      <p>Le pilier "Tranches" contient trois divisions disposÃ©es de haut en bas et Ã©tiquetÃ©es "user", "post", et "comment". La division "post" est reliÃ©e au troisiÃ¨me pilier "Segments" de la mÃªme maniÃ¨re, ce qui montre que c'est le contenu de "post".</p>
      <p>Le pilier "Segments" contient trois divisions, disposÃ©es de haut en bas et Ã©tiquetÃ©es "ui", "model", et "api".</p>
   </figcaption>
</figure>

### Couches {#layers}

Les couches sont normalisÃ©es dans tous les projets FSD. Vous n'Ãªtes pas obligÃ© d'utiliser toutes les couches, mais leurs noms sont importants. Il y en a actuellement sept (de haut en bas) :

1. App\* â€” tout ce qui fait fonctionner l'application â€” routage, points d'entrÃ©e, styles globaux, fournisseurs.
2. Processes (obsolÃ¨te) â€” scÃ©narios complexes inter-pages.
3. Pages â€” pages complÃ¨tes ou grandes parties de pages dans un routage imbriquÃ©.
4. Widgets â€” gros morceaux autonomes de fonctionnalitÃ© ou d'UI, livrant gÃ©nÃ©ralement un cas d'utilisation complet.
5. Features â€” implÃ©mentations _rÃ©utilisÃ©es_ de fonctionnalitÃ©s complÃ¨tes du produit, c'est-Ã -dire des actions qui apportent de la valeur commerciale Ã  l'utilisateur.
6. Entities â€” entitÃ©s commerciales avec lesquelles le projet travaille, comme `user` ou `product`.
7. Shared\* â€” fonctionnalitÃ© rÃ©utilisable, surtout lorsqu'elle est dÃ©tachÃ©e des spÃ©cificitÃ©s du projet ou de l'entreprise, bien que ce ne soit pas nÃ©cessairement le cas.

_\* â€” ces couches, App et Shared, contrairement aux autres, n'ont pas de tranches et sont composÃ©es directement de segments._

Le principe avec les couches est qu'un module d'une couche ne peut connaÃ®tre et importer que des modules des couches strictement infÃ©rieures.

### Tranches {#slices}

Les tranches partitionnent le code par domaine commercial. Vous Ãªtes libre de choisir n'importe quel nom pour elles et de crÃ©er autant de tranches que vous le souhaitez. Les tranches rendent votre codebase plus facile Ã  naviguer en gardant les modules logiquement liÃ©s ensemble.

Les tranches ne peuvent pas utiliser d'autres tranches sur la mÃªme couche, ce qui permet d'assurer une forte cohÃ©sion et un faible couplage.

### Segments {#segments}

Les tranches, ainsi que les couches App et Shared, sont composÃ©es de segments, et les segments regroupent votre code par son objectif. Les noms des segments ne sont pas contraints par la norme, mais il existe plusieurs noms conventionnels pour les objectifs les plus courants :

- `ui` â€” tout ce qui est liÃ© Ã  l'affichage de l'UI : composants UI, formatage des dates, styles, etc.
- `api` â€” interactions avec le backend : fonctions de requÃªtes, types de donnÃ©es, mappeurs, etc.
- `model` â€” le modÃ¨le de donnÃ©es : schÃ©mas, interfaces, stores, et logique mÃ©tier.
- `lib` â€” code de bibliothÃ¨que dont d'autres modules sur cette tranche ont besoin.
- `config` â€” fichiers de configuration et drapeaux de fonctionnalitÃ©s.

En gÃ©nÃ©ral, ces segments suffisent pour la plupart des couches. Vous ne crÃ©eriez vos propres segments que dans Shared ou App, mais ce n'est pas une rÃ¨gle stricte.

## Avantages {#advantages}

- **UniformitÃ©**  
  Ã‰tant donnÃ© que la structure est normalisÃ©e, les projets deviennent plus uniformes, ce qui facilite l'intÃ©gration des nouveaux membres dans l'Ã©quipe.

- **StabilitÃ© face aux changements et aux refactorisations**  
  Un module sur une couche ne peut pas utiliser d'autres modules sur la mÃªme couche, ni ceux des couches supÃ©rieures.  
  Cela vous permet d'effectuer des modifications isolÃ©es sans consÃ©quences imprÃ©vues sur le reste de l'application.

- **RÃ©utilisation contrÃ´lÃ©e de la logique**  
  Selon la couche, vous pouvez rendre le code trÃ¨s rÃ©utilisable ou trÃ¨s local.  
  Cela permet de maintenir un Ã©quilibre entre le principe **DRY** (Don't Repeat Yourself) et la praticitÃ©.

- **Orientation vers les besoins commerciaux et des utilisateurs**  
  L'application est divisÃ©e en domaines commerciaux et l'utilisation du langage commercial est encouragÃ©e dans la dÃ©nomination, afin que vous puissiez effectuer un travail utile pour le produit sans avoir Ã  comprendre en profondeur toutes les autres parties du projet.

## Adoption incrÃ©mentale {#incremental-adoption}

Si vous avez une base de code existante que vous souhaitez migrer vers FSD, nous suggÃ©rons la stratÃ©gie suivante. Nous l'avons trouvÃ©e utile lors de notre propre expÃ©rience de migration.

1. Commencez lentement Ã  structurer les modules des couches App et Shared, module par module, pour crÃ©er une base solide.

2. Distribuez toute l'UI existante sur les Widgets et Pages en prenant de grandes lignes, mÃªme si elles ont des dÃ©pendances qui violent les rÃ¨gles de FSD.

3. Commencez progressivement Ã  rÃ©soudre les violations d'importation et Ã  extraire les Entities et Ã©ventuellement mÃªme les Features.

Il est conseillÃ© de ne pas ajouter de nouvelles entitÃ©s importantes pendant la refactorisation ou de ne refactoriser que certaines parties du projet.

## Ã‰tapes suivantes {#next-steps}

- **Vous voulez bien comprendre comment penser en FSD ?** Consultez le [Tutoriel][tutorial].
- **Vous prÃ©fÃ©rez apprendre par des exemples ?** Nous en avons beaucoup dans la section [Exemples][examples].
- **Des questions ?** Venez sur notre [chat Telegram][ext-telegram] et obtenez de l'aide de la communautÃ©.

[tutorial]: /docs/get-started/tutorial
[examples]: /examples
[migration]: /docs/guides/migration/from-custom
[ext-steiger]: https://github.com/feature-sliced/steiger
[ext-tools]: https://github.com/feature-sliced/awesome?tab=readme-ov-file#tools
[ext-telegram]: https://t.me/feature_sliced
