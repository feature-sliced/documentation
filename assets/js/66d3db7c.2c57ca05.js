"use strict";(self.webpackChunk_feature_sliced_documentation=self.webpackChunk_feature_sliced_documentation||[]).push([["146"],{3862:function(e,t,n){n.r(t),n.d(t,{frontMatter:()=>o,default:()=>h,toc:()=>d,metadata:()=>s,assets:()=>c,contentTitle:()=>a});var s=JSON.parse('{"id":"guides/examples/types","title":"Types","description":"This guide concerns data types from typed languages like TypeScript and describes where they fit within FSD.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/guides/examples/types.md","sourceDirName":"guides/examples","slug":"/guides/examples/types","permalink":"/documentation/docs/guides/examples/types","draft":false,"unlisted":false,"editUrl":"https://github.com/feature-sliced/documentation/edit/master/i18n/en/docusaurus-plugin-content-docs/current/guides/examples/types.md","tags":[],"version":"current","lastUpdatedAt":1753997005000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"guidesSidebar","previous":{"title":"Authentication","permalink":"/documentation/docs/guides/examples/auth"},"next":{"title":"Page layouts","permalink":"/documentation/docs/guides/examples/page-layout"}}'),i=n(4132),r=n(9447);let o={sidebar_position:2},a="Types",c={},d=[{value:"Utility types",id:"utility-types",level:2},{value:"Business entities and their cross-references",id:"business-entities-and-their-cross-references",level:2},{value:"Data transfer objects and mappers",id:"data-transfer-objects-and-mappers",level:2},{value:"Where to put DTOs",id:"where-to-put-dtos",level:3},{value:"Where to put mappers",id:"where-to-put-mappers",level:3},{value:"How to deal with nested DTOs",id:"how-to-deal-with-nested-dtos",level:3},{value:"Global types and Redux",id:"global-types-and-redux",level:2},{value:"Enums",id:"enums",level:2},{value:"Type validation schemas and Zod",id:"type-validation-schemas-and-zod",level:2},{value:"Typings of component props and context",id:"typings-of-component-props-and-context",level:2},{value:"Ambient declaration files (<code>*.d.ts</code>)",id:"ambient-declaration-files-dts",level:2},{value:"Auto-generation of types",id:"auto-generation-of-types",level:2}];function l(e){let t={a:"a",admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"types",children:"Types"})}),"\n",(0,i.jsx)(t.p,{children:"This guide concerns data types from typed languages like TypeScript and describes where they fit within FSD."}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsx)(t.p,{children:"Is your question not covered by this guide? Post your question by leaving feedback on this article (blue button on the right) and we will consider expanding this guide!"})}),"\n",(0,i.jsx)(t.h2,{id:"utility-types",children:"Utility types"}),"\n",(0,i.jsx)(t.p,{children:"Utility types are types that don't have much meaning on their own and are usually used with other types. For example:"}),"\n",(0,i.jsxs)("figure",{children:[(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"type ArrayValues<T extends readonly unknown[]> = T[number];\n"})}),(0,i.jsx)("figcaption",{children:(0,i.jsxs)(t.p,{children:["Source: ",(0,i.jsx)(t.a,{href:"https://github.com/sindresorhus/type-fest/blob/main/source/array-values.d.ts",children:"https://github.com/sindresorhus/type-fest/blob/main/source/array-values.d.ts"})]})})]}),"\n",(0,i.jsxs)(t.p,{children:["To make utility types available across your project, either install a library like ",(0,i.jsx)(t.a,{href:"https://github.com/sindresorhus/type-fest",children:(0,i.jsx)(t.code,{children:"type-fest"})}),", or create your own library in ",(0,i.jsx)(t.code,{children:"shared/lib"}),". Make sure to clearly indicate what new types ",(0,i.jsx)(t.em,{children:"should"})," be added to this library, and what types ",(0,i.jsx)(t.em,{children:"don't belong"})," there. For example, call it ",(0,i.jsx)(t.code,{children:"shared/lib/utility-types"})," and add a README inside that describes what is a utility type in your team."]}),"\n",(0,i.jsx)(t.p,{children:"Don't overestimate the potential reusability of a utility type. Just because it can be reused, doesn't mean it will be, and as such, not every utility type needs to be in Shared. Some utility types are fine right next to where they are needed:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\uD83D\uDCC2 pages","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\uD83D\uDCC2 home","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\uD83D\uDCC2 api","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"\uD83D\uDCC4 ArrayValues.ts (utility type)"}),"\n",(0,i.jsx)(t.li,{children:"\uD83D\uDCC4 getMemoryUsageMetrics.ts (the code that uses the utility type)"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsxs)(t.p,{children:["Resist the temptation to create a ",(0,i.jsx)(t.code,{children:"shared/types"})," folder, or to add a ",(0,i.jsx)(t.code,{children:"types"}),' segment to your slices. The category "types" is similar to the category "components" or "hooks" in that it describes what the contents are, not what they are for. Segments should describe the purpose of the code, not the essence.']})}),"\n",(0,i.jsx)(t.h2,{id:"business-entities-and-their-cross-references",children:"Business entities and their cross-references"}),"\n",(0,i.jsxs)(t.p,{children:["Among the most important types in an app are the types of business entities, i.e. the real-world things that your app works with. For example, in a music streaming app, you might have business entities ",(0,i.jsx)(t.em,{children:"Song"}),", ",(0,i.jsx)(t.em,{children:"Album"}),", etc."]}),"\n",(0,i.jsxs)(t.p,{children:["Business entities often come from the backend, so the first step is to type the backend responses. It's convenient to have a function to make a request to every endpoint, and to type the response of this function. For extra type safety, you may want to run the response through a schema validation library like ",(0,i.jsx)(t.a,{href:"https://zod.dev",children:"Zod"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"For example, if you keep all your requests in Shared, you could do it like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="shared/api/songs.ts"',children:"import type { Artist } from \"./artists\";\n\ninterface Song {\n  id: number;\n  title: string;\n  artists: Array<Artist>;\n}\n\nexport function listSongs() {\n  return fetch('/api/songs').then((res) => res.json() as Promise<Array<Song>>);\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["You might notice that the ",(0,i.jsx)(t.code,{children:"Song"})," type references a different entity, ",(0,i.jsx)(t.code,{children:"Artist"}),". This is a benefit of storing your requests in Shared \u2014 real-world types are often intertwined. If we kept this function in ",(0,i.jsx)(t.code,{children:"entities/song/api"}),", we wouldn't be able to simply import ",(0,i.jsx)(t.code,{children:"Artist"})," from ",(0,i.jsx)(t.code,{children:"entities/artist"}),", because FSD restricts cross-imports between slices with ",(0,i.jsx)(t.a,{href:"/docs/reference/layers#import-rule-on-layers",children:"the import rule on layers"}),":"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"A module in a slice can only import other slices when they are located on layers strictly below."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"There are two ways to deal with this issue:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Parametrize your types"}),(0,i.jsx)(t.br,{}),"\n","You can make your types accept type arguments as slots for connections with other entities, and even impose constraints on those slots. For example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="entities/song/model/song.ts"',children:"interface Song<ArtistType extends { id: string }> {\n  id: number;\n  title: string;\n  artists: Array<ArtistType>;\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This works better for some types than others. A simple type like ",(0,i.jsx)(t.code,{children:"Cart = { items: Array<Product> }"})," can easily be made to work with any type of product. More connected types, like ",(0,i.jsx)(t.code,{children:"Country"})," and ",(0,i.jsx)(t.code,{children:"City"}),", may not be as easy to separate."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Cross-import (but do it right)"}),(0,i.jsx)(t.br,{}),"\n","To make cross-imports between entities in FSD, you can use a special public API specifically for each slice that will be cross-importing. For example, if we have entities ",(0,i.jsx)(t.code,{children:"song"}),", ",(0,i.jsx)(t.code,{children:"artist"}),", and ",(0,i.jsx)(t.code,{children:"playlist"}),", and the latter two need to reference ",(0,i.jsx)(t.code,{children:"song"}),", we can make two special public APIs for both of them in the ",(0,i.jsx)(t.code,{children:"song"})," entity with the ",(0,i.jsx)(t.code,{children:"@x"})," notation:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\uD83D\uDCC2 entities","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\uD83D\uDCC2 song","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\uD83D\uDCC2 @x","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\uD83D\uDCC4 artist.ts (a public API for the ",(0,i.jsx)(t.code,{children:"artist"})," entity to import from)"]}),"\n",(0,i.jsxs)(t.li,{children:["\uD83D\uDCC4 playlist.ts (a public API for the ",(0,i.jsx)(t.code,{children:"playlist"})," entity to import from)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.li,{children:"\uD83D\uDCC4 index.ts (regular public API)"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The contents of a file ",(0,i.jsx)(t.code,{children:"\uD83D\uDCC4 entities/song/@x/artist.ts"})," are similar to ",(0,i.jsx)(t.code,{children:"\uD83D\uDCC4 entities/song/index.ts"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="entities/song/@x/artist.ts"',children:'export type { Song } from "../model/song.ts";\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Then the ",(0,i.jsx)(t.code,{children:"\uD83D\uDCC4 entities/artist/model/artist.ts"})," can import ",(0,i.jsx)(t.code,{children:"Song"})," like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="entities/artist/model/artist.ts"',children:'import type { Song } from "entities/song/@x/artist";\n\nexport interface Artist {\n  name: string;\n  songs: Array<Song>;\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"By making explicit connections between entities, we stay on top of inter-dependencies and maintain a decent level of domain separation."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"data-transfer-objects-and-mappers",children:"Data transfer objects and mappers"}),"\n",(0,i.jsx)(t.p,{children:"Data transfer objects, or DTOs, is a term that describes the shape of data that comes from the backend. Sometimes, the DTO is fine to use as is, but sometimes it's inconvenient for the frontend. That's where mappers come in \u2014 they transform a DTO into a more convenient shape."}),"\n",(0,i.jsx)(t.h3,{id:"where-to-put-dtos",children:"Where to put DTOs"}),"\n",(0,i.jsx)(t.p,{children:"If you have backend types in a separate package (for example, if you share code between the frontend and the backend), then just import your DTOs from there and you're done! If you don't share code between the backend and frontend, then you need to keep DTOs somewhere in your frontend codebase, and we will explore this case below."}),"\n",(0,i.jsxs)(t.p,{children:["If you have your request functions in ",(0,i.jsx)(t.code,{children:"shared/api"}),", that's where the DTOs should be, right next to the function that uses them:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="shared/api/songs.ts"',children:'import type { ArtistDTO } from "./artists";\n\ninterface SongDTO {\n  id: number;\n  title: string;\n  artist_ids: Array<ArtistDTO["id"]>;\n}\n\nexport function listSongs() {\n  return fetch(\'/api/songs\').then((res) => res.json() as Promise<Array<SongDTO>>);\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"As mentioned in the previous section, storing your requests and DTOs in Shared comes with the benefit of being able to reference other DTOs."}),"\n",(0,i.jsx)(t.h3,{id:"where-to-put-mappers",children:"Where to put mappers"}),"\n",(0,i.jsxs)(t.p,{children:["Mappers are functions that accept a DTO for transformation, and as such, they should be located near the definition of the DTO. In practice this means that if your requests and DTOs are defined in ",(0,i.jsx)(t.code,{children:"shared/api"}),", then the mappers should go there as well:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="shared/api/songs.ts"',children:'import type { ArtistDTO } from "./artists";\n\ninterface SongDTO {\n  id: number;\n  title: string;\n  disc_no: number;\n  artist_ids: Array<ArtistDTO["id"]>;\n}\n\ninterface Song {\n  id: string;\n  title: string;\n  /** The full title of the song, including the disc number. */\n  fullTitle: string;\n  artistIds: Array<string>;\n}\n\nfunction adaptSongDTO(dto: SongDTO): Song {\n  return {\n    id: String(dto.id),\n    title: dto.title,\n    fullTitle: `${dto.disc_no} / ${dto.title}`,\n    artistIds: dto.artist_ids.map(String),\n  };\n}\n\nexport function listSongs() {\n  return fetch(\'/api/songs\').then(async (res) => (await res.json()).map(adaptSongDTO));\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"If your requests and stores are defined in entity slices, then all this code would go there, keeping in mind the limitations of cross-imports between slices:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="entities/song/api/dto.ts"',children:'import type { ArtistDTO } from "entities/artist/@x/song";\n\nexport interface SongDTO {\n  id: number;\n  title: string;\n  disc_no: number;\n  artist_ids: Array<ArtistDTO["id"]>;\n}\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="entities/song/api/mapper.ts"',children:'import type { SongDTO } from "./dto";\n\nexport interface Song {\n  id: string;\n  title: string;\n  /** The full title of the song, including the disc number. */\n  fullTitle: string;\n  artistIds: Array<string>;\n}\n\nexport function adaptSongDTO(dto: SongDTO): Song {\n  return {\n    id: String(dto.id),\n    title: dto.title,\n    fullTitle: `${dto.disc_no} / ${dto.title}`,\n    artistIds: dto.artist_ids.map(String),\n  };\n}\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="entities/song/api/listSongs.ts"',children:"import { adaptSongDTO } from \"./mapper\";\n\nexport function listSongs() {\n  return fetch('/api/songs').then(async (res) => (await res.json()).map(adaptSongDTO));\n}\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="entities/song/model/songs.ts"',children:'import { createSlice, createEntityAdapter } from "@reduxjs/toolkit";\n\nimport { listSongs } from "../api/listSongs";\n\nexport const fetchSongs = createAsyncThunk(\'songs/fetchSongs\', listSongs);\n\nconst songAdapter = createEntityAdapter();\nconst songsSlice = createSlice({\n  name: "songs",\n  initialState: songAdapter.getInitialState(),\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(fetchSongs.fulfilled, (state, action) => {\n      songAdapter.upsertMany(state, action.payload);\n    })\n  },\n});\n'})}),"\n",(0,i.jsx)(t.h3,{id:"how-to-deal-with-nested-dtos",children:"How to deal with nested DTOs"}),"\n",(0,i.jsxs)(t.p,{children:["The most problematic part is when a response from the backend contains several entities. For example, if the song included not just the authors' IDs, but the entire author objects. In this case, it is impossible for entities not to know about each other (unless we want to discard the data or have a firm conversation with the backend team). Instead of coming up with solutions for indirect connections between slices (such as a common middleware that would dispatch actions to other slices), prefer explicit cross-imports with the ",(0,i.jsx)(t.code,{children:"@x"})," notation. Here is how we can implement it with Redux Toolkit:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="entities/song/model/songs.ts"',children:"import {\n  createSlice,\n  createEntityAdapter,\n  createAsyncThunk,\n  createSelector,\n} from '@reduxjs/toolkit'\nimport { normalize, schema } from 'normalizr'\n\nimport { getSong } from \"../api/getSong\";\n\n// Define normalizr entity schemas\nexport const artistEntity = new schema.Entity('artists')\nexport const songEntity = new schema.Entity('songs', {\n  artists: [artistEntity],\n})\n\nconst songAdapter = createEntityAdapter()\n\nexport const fetchSong = createAsyncThunk(\n  'songs/fetchSong',\n  async (id: string) => {\n    const data = await getSong(id)\n    // Normalize the data so reducers can load a predictable payload, like:\n    // `action.payload = { songs: {}, artists: {} }`\n    const normalized = normalize(data, songEntity)\n    return normalized.entities\n  }\n)\n\nexport const slice = createSlice({\n  name: 'songs',\n  initialState: songAdapter.getInitialState(),\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(fetchSong.fulfilled, (state, action) => {\n      songAdapter.upsertMany(state, action.payload.songs)\n    })\n  },\n})\n\nconst reducer = slice.reducer\nexport default reducer\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="entities/song/@x/artist.ts"',children:'export { fetchSong } from "../model/songs";\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="entities/artist/model/artists.ts"',children:"import { createSlice, createEntityAdapter } from '@reduxjs/toolkit'\n\nimport { fetchSong } from 'entities/song/@x/artist'\n\nconst artistAdapter = createEntityAdapter()\n\nexport const slice = createSlice({\n  name: 'users',\n  initialState: artistAdapter.getInitialState(),\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(fetchSong.fulfilled, (state, action) => {\n      // And handle the same fetch result by inserting the artists here\n      artistAdapter.upsertMany(state, action.payload.artists)\n    })\n  },\n})\n\nconst reducer = slice.reducer\nexport default reducer\n"})}),"\n",(0,i.jsx)(t.p,{children:"This slightly limits the benefits of slice isolation, but it accurately represents a connection between these two entities that we have no control over. If these entities are to ever be refactored, they have to be refactored together."}),"\n",(0,i.jsx)(t.h2,{id:"global-types-and-redux",children:"Global types and Redux"}),"\n",(0,i.jsx)(t.p,{children:"Global types are types that will be used across the whole application. There are two kinds of global types, based on what they need to know about:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Generic types that don't have any application specifics"}),"\n",(0,i.jsx)(t.li,{children:"Types that need to know about the whole application"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The first case is simple to resolve \u2014 place your types in Shared, in an appropriate segment. For example, if you have an interface for a global variable for analytics, you can put it in ",(0,i.jsx)(t.code,{children:"shared/analytics"}),"."]}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsxs)(t.p,{children:["Avoid creating the ",(0,i.jsx)(t.code,{children:"shared/types"}),' folder. It groups unrelated things based only on the property of "being a type", and that property is usually not useful when searching for code in a project.']})}),"\n",(0,i.jsx)(t.p,{children:"The second case is commonly encountered in projects with Redux without RTK. Your final store type is only available once you add all the reducers together, but this store type needs to be available to selectors that you use across the app. For example, here's your typical store definition:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="app/store/index.ts"',children:'import { combineReducers, rootReducer } from "redux";\n\nimport { songReducer } from "entities/song";\nimport { artistReducer } from "entities/artist";\n\nconst rootReducer = combineReducers(songReducer, artistReducer);\n\nconst store = createStore(rootReducer);\n\ntype RootState = ReturnType<typeof rootReducer>;\ntype AppDispatch = typeof store.dispatch;\n'})}),"\n",(0,i.jsxs)(t.p,{children:["It would be nice to have typed Redux hooks ",(0,i.jsx)(t.code,{children:"useAppDispatch"})," and ",(0,i.jsx)(t.code,{children:"useAppSelector"})," in ",(0,i.jsx)(t.code,{children:"shared/store"}),", but they cannot import ",(0,i.jsx)(t.code,{children:"RootState"})," and ",(0,i.jsx)(t.code,{children:"AppDispatch"})," from the App layer due to the ",(0,i.jsx)(t.a,{href:"/docs/reference/layers#import-rule-on-layers",children:"import rule on layers"}),":"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"A module in a slice can only import other slices when they are located on layers strictly below."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The recommended solution in this case is to create an implicit dependency between layers Shared and App. These two types, ",(0,i.jsx)(t.code,{children:"RootState"})," and ",(0,i.jsx)(t.code,{children:"AppDispatch"})," are unlikely to change, and they will be familiar to Redux developers, so we don't have to worry about them as much."]}),"\n",(0,i.jsx)(t.p,{children:"In TypeScript, you can do it by declaring the types as global like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="app/store/index.ts"',children:"/* same content as in the code block before\u2026 */\n\ndeclare type RootState = ReturnType<typeof rootReducer>;\ndeclare type AppDispatch = typeof store.dispatch;\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="shared/store/index.ts"',children:'import { useDispatch, useSelector, type TypedUseSelectorHook } from "react-redux";\n\nexport const useAppDispatch = useDispatch.withTypes<AppDispatch>()\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n'})}),"\n",(0,i.jsx)(t.h2,{id:"enums",children:"Enums"}),"\n",(0,i.jsxs)(t.p,{children:["The general rule with enums is that they should be defined ",(0,i.jsx)(t.strong,{children:"as close to the usage locations as possible"}),". When an enum represents values specific to a single feature, it should be defined in that same feature."]}),"\n",(0,i.jsxs)(t.p,{children:["The choice of segment should be dictated by usage locations as well. If your enum contains, for example, positions of a toast on the screen, it should be placed in the ",(0,i.jsx)(t.code,{children:"ui"})," segment. If it represents the loading state of a backend operation, it should be placed in the ",(0,i.jsx)(t.code,{children:"api"})," segment."]}),"\n",(0,i.jsxs)(t.p,{children:["Some enums are truly common across the whole project, like general backend response statuses or design system tokens. In this case, you can place them in Shared, and choose the segment based on what the enum represents (",(0,i.jsx)(t.code,{children:"api"})," for response statuses, ",(0,i.jsx)(t.code,{children:"ui"})," for design tokens, etc.)."]}),"\n",(0,i.jsx)(t.h2,{id:"type-validation-schemas-and-zod",children:"Type validation schemas and Zod"}),"\n",(0,i.jsxs)(t.p,{children:["If you want to validate that your data conforms to a certain shape or constraints, you can define a validation schema. In TypeScript, a popular library for this job is ",(0,i.jsx)(t.a,{href:"https://zod.dev",children:"Zod"}),". Validation schemas should also be colocated with the code that uses them, as much as possible."]}),"\n",(0,i.jsxs)(t.p,{children:["Validation schemas are similar to mappers (as discussed in the ",(0,i.jsx)(t.a,{href:"#data-transfer-objects-and-mappers",children:"Data transfer objects and mappers"})," section) in the sense that they take a data transfer object and parse it, producing an error if the parsing fails."]}),"\n",(0,i.jsxs)(t.p,{children:["One of the most common cases of validation is for the data that comes from the backend. Typically, you want to fail the request when the data doesn't match the schema, so it makes sense to put the schema in the same place as the request function, which is usually the ",(0,i.jsx)(t.code,{children:"api"})," segment."]}),"\n",(0,i.jsxs)(t.p,{children:["If your data comes through user input, like a form, the validation should happen as the data is being entered. You can place your schema in the ",(0,i.jsx)(t.code,{children:"ui"})," segment, next to the form component, or in the ",(0,i.jsx)(t.code,{children:"model"})," segment, if the ",(0,i.jsx)(t.code,{children:"ui"})," segment is too crowded."]}),"\n",(0,i.jsx)(t.h2,{id:"typings-of-component-props-and-context",children:"Typings of component props and context"}),"\n",(0,i.jsxs)(t.p,{children:["In general, it's best to keep the props or context interface in the same file as the component or context that uses them. If you have a framework with single-file components, like Vue or Svelte, and you can't define the props interface in the same file, or you want to share that interface between several components, create a separate file in the same folder, typically, the ",(0,i.jsx)(t.code,{children:"ui"})," segment."]}),"\n",(0,i.jsx)(t.p,{children:"Here's an example with JSX (React or Solid):"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="pages/home/ui/RecentActions.tsx"',children:"interface RecentActionsProps {\n  actions: Array<{ id: string; text: string }>;\n}\n\nexport function RecentActions({ actions }: RecentActionsProps) {\n  /* \u2026 */\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"And here's an example with the interface stored in a separate file for Vue:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="pages/home/ui/RecentActionsProps.ts"',children:"export interface RecentActionsProps {\n  actions: Array<{ id: string; text: string }>;\n}\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-html",metastring:'title="pages/home/ui/RecentActions.vue"',children:'<script setup lang="ts">\n  import type { RecentActionsProps } from "./RecentActionsProps";\n\n  const props = defineProps<RecentActionsProps>();\n<\/script>\n'})}),"\n",(0,i.jsxs)(t.h2,{id:"ambient-declaration-files-dts",children:["Ambient declaration files (",(0,i.jsx)(t.code,{children:"*.d.ts"}),")"]}),"\n",(0,i.jsxs)(t.p,{children:["Some packages, for example, ",(0,i.jsx)(t.a,{href:"https://vitejs.dev",children:"Vite"})," or ",(0,i.jsx)(t.a,{href:"https://www.totaltypescript.com/ts-reset",children:"ts-reset"}),", require ambient declaration files to work across your app. Usually, they aren't large or complicated, so they often don't require any architecting, it's fine to just throw them in the ",(0,i.jsx)(t.code,{children:"src/"})," folder. To keep the ",(0,i.jsx)(t.code,{children:"src"})," more organized, you can keep them on the App layer, in ",(0,i.jsx)(t.code,{children:"app/ambient/"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Other packages simply don't have typings, and you might want to declare them as untyped or even write your own typings for them. A good place for those typings would be ",(0,i.jsx)(t.code,{children:"shared/lib"}),", in a folder like ",(0,i.jsx)(t.code,{children:"shared/lib/untyped-packages"}),". Create a ",(0,i.jsx)(t.code,{children:"%LIBRARY_NAME%.d.ts"})," file there and declare the types you need:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="shared/lib/untyped-packages/use-react-screenshot.d.ts"',children:"// This library doesn't have typings, and we didn't want to bother writing our own.\ndeclare module \"use-react-screenshot\";\n"})}),"\n",(0,i.jsx)(t.h2,{id:"auto-generation-of-types",children:"Auto-generation of types"}),"\n",(0,i.jsxs)(t.p,{children:["It's common to generate types from external sources, for example, generating backend types from an OpenAPI schema. In this case, create a dedicated place in your codebase for these types, like ",(0,i.jsx)(t.code,{children:"shared/api/openapi"}),". Ideally, you should also include a README in that folder that describes what these files are, how to regenerate them, etc."]})]})}function h(e={}){let{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},9447:function(e,t,n){n.d(t,{Z:()=>a,a:()=>o});var s=n(9546);let i={},r=s.createContext(i);function o(e){let t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);